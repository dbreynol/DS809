Another way that a time series may violate stationarity is with seasonality. For example, the Leisure and Hospitality sector of the economy spikes in the summer and dips in the winter months. We will look at employment (in thousands) in this sector since 2010:

```{r echo=TRUE}
leisure = fpp3::us_employment %>% 
  filter(Title == "Leisure and Hospitality", year(Month) >= 2010) %>% 
  select(Month, Employed)
```

- Make a plot of this time series and comment on the trend and the seasonality.

- We can use our differencing tool to try to make this data stationary. Since this data has a strong seasonal component, we can take a seasonal difference, using `employed2 = diff(leisure$Employed, 12)`, which creates a transformed time series, `employed2`. Make a plot of this time series along with an ACF plot. Is this transformed time series stationary?

```{r eval=FALSE}
ts2 = diff(leisure$Employed, 12)
plot(ts2)
acf(ts2)
```

- Take the first difference of `employed2`. Let's call this new time series `employed3`.  Plot this time series. Does `employed3` appear to be stationary?

```{r eval=F}
ts3 = diff(ts2, 1)
plot(ts3)
acf(ts3, type = "partial")
```

- Coerce `employed3` to a time series object using, `ts(employed3, frequency = 12, start = c(2010,1), end = c(2019,9))`. Now, use `auto.arima` to fit a time series model to this time series object. What model was selected?

```{r eval=FALSE}
employed_ts = ts(leisure$Employed, frequency = 12, start = c(2010,1), end = c(2019,9))
fit1 = auto.arima(employed_ts)
fr2 = forecast(fit1, h=12)
plot(fr2)
```

- Use `forecast` to make a plot of the next twelve months of data. Does the model capture the trend and seasonality?

```{r eval=FALSE}
plot(log(h02))
y2 = log(h02)
y3 = diff(y2,12)
plot(y3)
#adf.test(y3)
test0 = ur.df(y2)
summary(test0)

yt = c(0)
for(i in 2:100) {yt[i] = yt[i-1] + rnorm(1)}
summary ( ur.df(yt) )
```





# State Space Models

## (Noisy) Exponential Smoothing

## State Space Models

```{r}
cs = getSymbols('UMCSENT', src = "FRED")
cs_df = data.frame(date = ymd(index(UMCSENT)), sent = UMCSENT$UMCSENT) %>% filter(date > mdy("4-1-2020"))
ggplot(cs_df, aes(x = date, y = UMCSENT)) + geom_line()

```


```{r}
m0 = auto.arima(cs_df$UMCSENT)
h = forecast(m0, h = 7)

cs_df$t = 1:nrow(cs_df)
m1 = lm(UMCSENT ~ t, data = cs_df)
summary(m1)
predict(m1, newdata = data.frame(t = 44:48), interval = "prediction", level = .95)
```

general format

ex w/ nile

forecast forward consumer sentiment (using regression / AR model and state space - show differences like this: https://atsa-es.github.io/atsa/Lectures/Week%203/lec_05_univariate_state_space.html#25    )


```{r}
library(statespacer)

y = matrix(cs_df$UMCSENT)
fit <- statespacer(y = y,
                   local_level_ind = TRUE,
                   initial = 0.5*log(var(y)),
                   verbose = TRUE)




plotdf = data.frame(y = y, level = fit$smoothed$level, date = cs_df$date)

ggplot(plotdf) +
  geom_point(aes(x = date, y = y)) +
  geom_line(aes(x = date, y = level))

fc = predict(fit, forecast_period = 5, nsim = 10)

plot(1:5, fc$y_fc, type = 'l')
lines(1:5, fc$sim$y[, 1, 1], type = 'p')


lines(1871:1970, fit$smoothed$level, type = 'l')
lines(1871:1970, fit$smoothed$level + qnorm(0.95) * sqrt(fit$smoothed$V[1,1,]),
      type = 'l', col = 'gray'
)
lines(1871:1970, fit$smoothed$level - qnorm(0.95) * sqrt(fit$smoothed$V[1,1,]),
      type = 'l', col = 'gray'
)



```

