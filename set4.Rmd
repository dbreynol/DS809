# Covariates



```{r}
#library(forecast)
#library(dynlm)

insurance %>% pivot_longer(-Month) %>% 
  ggplot(aes(x = Month, y = value)) + 
  geom_line(aes(color = name)) + 
  theme_minimal() + ggtitle("Advertising verus Quotes")
```

## Linear Regression

We begin by modeling $y=$ Quotes as a *linear function* of $x=$ TV Spend. That is, we have the following model:

\begin{align}
y_t = \beta_0 + \beta_1 x_t + e_t,
\end{align}

where $e_1, \ldots, e_t$ are mutually independent and each $e_t \sim \text{N}(0,\sigma^2)$.

```{r}
# option one - simple linear regression
linmod = lm(Quotes ~ TVadverts, data = insurance)
linmod %>% tidy %>% kable()
plot(residuals(linmod), type = "l")
```

When we do regressions using time series variables, it is common for the errors (residuals) to have a time series structure. This violates the usual assumption of independent errors made in ordinary least squares regression. The consequence is that the estimates of coefficients and their standard errors will be wrong if the time series structure of the errors is ignored.

## `dynlm` Linear Model

Another way of fitting a linear model to time series data is using the package `dynlm`. This package, through its namesake function `dynlm`, fits the same model as above but is noteworthy for its helpful set of functions related to time. Before showing those, let us fit the same model as above using `dynlm`.

```{r echo=TRUE}
# option two - time series regression: LM with very useful time functions
y = ts(insurance$Quotes, frequency = 4)
x1 = ts(insurance$TVadverts, frequency = 4)
md = dynlm(y ~ x1 )
```

```{r}

md2 = dynlm(y ~ x1 + L(x1,1) + trend(y) + season(y))
#summary(md2)
```


## Linear Regression with ARIMA Errors

```{r}
# option three - time series with ARIMA errors
m0 = auto.arima(insurance$Quotes, xreg = as.matrix(insurance$TVadverts))
#summary(m0)
checkresiduals(m0)
#m0 %>% tidy() %>% kable()
```

## State Space Model

### Framework

```{r}
m0 = ets(y, model = "ANN")
#summary(m0)
m1 = StructTS(y, type = "level")
#summary(m1)
plot(forecast(m0, h = 5))
```

### General Framework


### Specific Problem

```{r}
#library(bsts)
ss <- AddLocalLinearTrend(list(), y)
model1 <- bsts(y ~ x1,
               state.specification = ss,
               niter = 1000)

plot(model1)
fore = predict(model1, horizon = 4, newdata = rep(8,5))
plot(fore)
```

## Prophet
