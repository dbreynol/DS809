[["exploratory-analysis-of-time-series-data.html", "DS809 Set 1 Exploratory Analysis of Time Series Data 1.1 Time Series Data 1.2 Time Series EDA 1.3 Multiple Time Series 1.4 Autocorrelation 1.5 Lab 1", " DS809 David Reynolds 2024-01-01 Set 1 Exploratory Analysis of Time Series Data 1.1 Time Series Data A time series is an ordered sequence of observations, where the ordering is through time. Time series data creates unique problems for statistical modeling and inference. Traditional inference assumes that observations (data) are independent and identically distributed. Adjacent data points in time series data are not necessarily independent (uncorrelated). Most time series models aim to exploit such dependence. For instance, yesterday’s demand of a product may tell us something about today’s demand of a product. There are several different ways to represent time series data in R. We will use the tidyverse family of packages extensively in this class. This package includes the lubridate package, which includes functions to work with date-times. Two of the most common ways to represent time series data are using data frames in which one of the variables is a time object (such as POSIXct or Date) or using a time series object. These two representations are shown below with simulated trading data for a single 8-hour trading day. set.seed(1) # option 1: represent time series data within a data frame hr = seq(mdy_hm(&quot;12-11-2023 09:30&quot;), mdy_hm(&quot;12-11-2023 16:30&quot;), &#39;hour&#39;) # 8 hours pr = rnorm(8) # generate fake trading data trading_dat = data.frame(hr, pr) # option 2: represent time series data using a time series object trading_ts = ts(data = trading_dat$pr, start = 1, frequency = 8) 1.2 Time Series EDA The first thing to do in any data analysis is exploratory data analysis (EDA). Graphs enable many features of the data to be visualized, including patterns, unusual observations, changes over time, and relationships between variables. The features that are seen in plots of the data can then be incorporated into statistical models. R has several systems for making graphs. We will primarily use ggplot2, which is among the set of tidyverse packages and is one of the most versatile systems for plotting. We will use a data set from Kayak to motivate our analysis. conversions = read.csv(&quot;https://raw.githubusercontent.com/dbreynol/DS809/main/data/conversions.csv&quot;) knitr::kable(head(conversions)) datestamp country_code marketing_channel conversions 2014-11-01 be Display Ads 1174 2014-11-01 be KAYAK Deals Email 57 2014-11-01 be Search Engine Ads 1122 2014-11-01 be Search Engine Results 976 2014-11-01 fi Display Ads 12 2014-11-01 fi Search Engine Results 2 This dataset contains information on the total number of daily conversions by country and marketing channel. Let us focus our analysis on the US and fist visualize the number of conversions by day. This plot contains a lot of useful information. To gain insight into how conversions depend on marketing channel, we can use facets. Facets are subplots that display a time series for each marketing channel. Display ads and search engine ads are the dominant marketing channels. Both have a regular pattern that is likely a function of the day of week, with a higher number of conversions during weekdays as compared with weekends. We can explore this feature by aggregating over each weekday and visualizing how the distribution of conversions changes by day. Clearly, there are significant changes in the mean level of conversions across the week. This is a form of seasonality. It may be useful to see what the data look like when this weekday effect is removed. To do so, we could visualize the residuals from the following linear regression model: \\[\\begin{align} \\hat{\\text{conversions}} = \\hat{\\beta}_0 + \\sum_{j=2}^7 \\bigg( \\hat{\\beta}_j \\times 1(\\text{weekday = j}) \\bigg), \\end{align}\\] where \\(j\\) indexes the day of week. The residuals from this model consist of each observation minus the mean for that particular weekday. This allows us to more clearly see the trend across the date range, removing the effect of the weekly pattern. 1.3 Multiple Time Series Often we will want to develop insight into the relationship between several variables. To illustrate, we will use quarterly data on GDP per capita and the Case Shiller Home Price Index (both from the FRED database). It looks like these two time series track pretty closely to one another. We could fit a linear regression to this data in order to estimate the expected change in the Case Shiller Index for a unit ($1) change in GDP/ capital term estimate std.error statistic p.value (Intercept) -556.2290146 33.8244315 -16.44459 0 gdp 0.0126208 0.0005663 22.28669 0 Further, we could also examine the residuals to gain insight into what is missing from this model. The model severely underestimates the house index starting during the pandemic. There is a clear pattern to these residuals. Is this a problem? 1.4 Autocorrelation One of the assumptions of the linear regression model is that the errors are independent and identically distributed. That is, for the model, \\[\\begin{align} y = X \\beta + \\epsilon, \\end{align}\\] The error vector, \\(\\epsilon \\sim N(0, \\sigma^2)\\). This implies that there is no correlation structure to the residuals. One way to check that this is true is to check for the absence of correlation in the observed residuals. To review this concept, we’ll start with a definition for covariance. For two vectors of data, \\(x\\) and \\(y\\), the covariance between the two is, \\[\\begin{align} \\text{cov}(x,y) &amp;= \\frac{ \\sum_i (x_i - \\bar{x})(y_i - \\bar{y})}{n-1} \\end{align}\\] Correlation is a dimensionless measure of the linear association between two variables. It is defined as the covariance scaled by the standard deviations. That is, \\[\\begin{align} \\text{cor}(x,y) &amp;= \\frac{\\text{cov}(x,y)}{\\sigma_x \\sigma_y} \\\\ &amp;= \\frac{ \\sum_i (x_i - \\bar{x})(y_i - \\bar{y})}{ \\sqrt{ \\sum_i (x_i - \\bar{x})^2 \\sum_i (y_i - \\bar{y})^2 }} \\end{align}\\] Let’s compute this quantity on some simulated data. set.seed(1) n = 5 x = rnorm(n) y = rnorm(n) sum( (x - mean(x)) * (y - mean(y))) / ( (n-1) * sd(x) * sd(y) ) cor(x, y) For time series data, there is a closely related concept called autocorrelation. Given a time series, \\(y_t\\), where \\(t=1,\\ldots,T\\), autocorrelation is the correlation between \\(y_t\\) and its lagged value, \\(y_{t-k}\\). That is, autocorrelation is the correlation of a time series with a delayed copy of itself, as a function of delay. Just as correlation is a function of covariance, autocorrelation is a function of autocovariance. The The (sample) autocovariance, \\(\\hat{\\gamma}\\) for a time series \\(y\\) at lag \\(k\\) is: \\[\\begin{align} \\hat{\\gamma}_k &amp;= \\text{cov}(y_t, y_{t-k}) \\\\ &amp;= \\frac{1}{T-k-1} \\sum_{t = k + 1}^{T} (y_t - \\bar{y})(y_{t-k} - \\bar{y}) \\end{align}\\] The (sample) autocorrelation function for lag \\(k\\), \\(\\hat{\\rho}_k\\), is simply the lag \\(k\\) autocovariance, \\(\\hat{\\gamma_k}\\) , scaled by the standard deviations. \\[\\begin{align} \\hat{\\rho}_k &amp;= \\frac{ \\hat{\\gamma_k} }{\\sigma_{y_t} \\sigma_{y_{t-k}}} \\\\ &amp;= \\frac{ \\hat{\\gamma_k} }{\\hat{\\gamma_0}}. \\end{align}\\] The second line follows from the linear regression assumption of constant variance. Here is a simple example of computing the lag 1 autocorrelation. a = c(1,2,3,4,5) a1 = c(1,2,3,4) a2 = c(2,3,4,5) # lag 1 autocorrelation sum( (a1 - mean(a)) * (a2 - mean(a))) / (sum( (a - mean(a))^2 ) ) # by hand (acf(a)) 1.5 Lab 1 Starting from the code chunk in Time Series Data, extend the simulated training data to a full week (December 11 through December 15, eight hours each day). Using the data frame representation, plot(trading_dat$hr, trading_dat$pr). Using the time series data, plot(trading_ts). What are the differences between these two plots? We can further hone in on the trend of the residuals at the end of Time Series EDA by computing and plotting a moving average. For a time series \\(y_t\\), \\(t = 1, \\ldots, T\\), a moving average of order \\(m\\) can be written, \\[\\begin{align} \\hat{y_t} = \\frac{1}{m} \\sum_{j=-k}^{k} y_{t+j}, \\end{align}\\] where \\(m=2k+1\\). The concept behind this technique is that observations that are close in time are likely to be close in value. Compute a moving average of order \\(m=7\\) for the residual time series and plot it along with the residuals in a single plot. Join the Kayak visits data (see below) to the conversions data from Time Series EDA. Use the inner_join function with the argument, by = c(“datestamp”, “country_code”, “marketing_channel”). Make a plot of user_visits and conversions by day. Standardize them if it makes sense. Then, fit a linear regression model with conversions as the reponse variable and user_visits as the explanatory variable. What is the estimated line equation? Finally, make a plot of the residuals from this model. visits = read.csv(&quot;https://raw.githubusercontent.com/dbreynol/DS809/main/data/visits.csv&quot;) visits$datestamp = ymd(visits$datestamp) Wrtie a function in R that takes two arguments: a time series (\\(y\\)) formatted as a vector and an integer (\\(k\\)) specifying a lag. The output for this function is the lag \\(k\\) autocorrelation for \\(y\\), using the formula in Autocorrelation. Compare the output of your function to the output from (acf(y)). An extra challenge is to allow \\(k\\) to be a vector of lags, in which case your function should return a vector of autocorrelation values. The partial autocorrelation function, \\(\\phi_k\\), measures the correlation between a time series \\(y_t\\) and a lagged copy \\(y_{t-k}\\), with the linear dependence of \\(\\{ y_{t-1}, y_{t-2}, \\ldots,y_{t-k-1} \\}\\) removed. When \\(k=1\\), \\(\\hat{\\phi}_k = \\hat{\\rho}_k\\). When \\(k&gt;1\\), \\[\\begin{align} \\hat{\\phi}_k = \\text{cor}(y_1 - \\hat{y_1}|\\{ y_2, \\ldots, y_{k-1} \\} , y_k - \\hat{y_k}|\\{ y_2, \\ldots, y_{k-1} \\} ), \\end{align}\\] where \\(\\hat{y_1}|\\{ y_2, \\ldots, y_{k-1} \\}\\) is the predicted \\(y_1\\) using the linear regression where \\(\\{ y_2, \\ldots, y_{k-1} \\}\\) are explanatory variables. Compute the lag 1 and 2 partial autocorrelations for the following simulated time series. Show your code and validate your answers using the pacf function. The window function may be useful to extract subsets of the time series vector. set.seed(1) ysim = arima.sim(n=1000, list(ar=c(.5))) (pacf(ysim)) "],["smoothing-decomposition-noise.html", "Set 2 Smoothing, Decomposition, Noise 2.1 Exponential Smoothing 2.2 Decomposition 2.3 Statistical Models 2.4 Stationarity 2.5 Lab 2", " Set 2 Smoothing, Decomposition, Noise 2.1 Exponential Smoothing An alternate way to smooth a time series, generally appropriate for a time series with no clear seasonality, is with exponential smoothing. Like the moving average, this method averages over recent observations but differs in that it assigns relatively more weight to observations that are relatively closer. This idea can be expressed as, \\[\\begin{align} \\hat{y}_{t+1 | t} = \\alpha y_t + (1-\\alpha) \\hat{y}_{t | t-1}, \\end{align}\\] where \\(\\hat{y}_{t+1 | t}\\) can be interpreted as the smoothed value of \\(y_{t+1}\\) given data up to time \\(t\\). So, for the first few smoothed values, we have: \\[\\begin{align} \\hat{y}_{1|0} &amp;= l_0 \\\\ \\hat{y}_{2|1} &amp;= \\alpha y_1 + (1-\\alpha) l_0 \\\\ \\hat{y}_{3|2} &amp;= \\alpha y_2 + (1-\\alpha) \\hat{y}_{2|1} \\\\ &amp;= \\alpha y_2 + (1-\\alpha) \\alpha y_1 + (1-\\alpha)^2 l_0 \\end{align}\\] Since we don’t have data prior to \\(y_1\\), we denote \\(\\hat{y}_{1 | 0} = l_0\\). Therefore, this model depends on two parameters, \\((l_0, \\alpha)\\). If we continue with the sequence above, each predicted value \\(\\hat{y_t}\\) can be expressed, \\[\\begin{align} \\hat{y}_{t+1 | t} = (1-\\alpha) ^ t l_0 + \\sum_{j=0}^{t-1} \\alpha (1-\\alpha) ^ j y_{t-j}. \\\\ \\end{align}\\] Let’s take a look at how this method depends on the parameters. In the plot above, of Albanian exports between 1991 and 2017, we display two smoothed time series (one for \\(\\alpha = 0.5\\) and one where \\(\\alpha = 0.9\\)). For any \\(\\alpha\\) between 0 and 1, the weights attached to the observations decrease exponentially as we go back in time, hence the name “exponential smoothing”. If \\(\\alpha\\) is small (i.e., close to 0), more weight is given to observations from the more distant past. If \\(\\alpha\\) is large (i.e., close to 1), more weight is given to the more recent observations. 2.1.1 Optimization The \\((\\alpha, l_0)\\) parameters can be estimated by minimizing the SSE: \\[\\begin{align} \\text{SSE} = \\sum_{i=i}^T \\bigg(y_t - \\hat{y}_{t | t-1} \\bigg)^2. \\end{align}\\] This is a non-linear optimization problem that you will solve in Lab 2! 2.2 Decomposition Time series data can exhibit a variety of patterns, and it is often helpful to split a time series into several components, each representing an underlying pattern category. In this section, we will aim to decompose a time series into three parts: a trend component (\\(T\\)), a seasonality component (\\(S\\)), and a random component (\\(R\\)). That is, for each observation \\(Y_t\\), we want to break it down into three parts: \\(Y_T = T_t + S_t + R_t\\). To illustrate, we will use a dataset on monthly retail employment in the US. Let’s first take a look at this data. # us_employment data frame from the &#39;fpp3&#39; package us_employment$date = mdy ( str_c( month(us_employment$Month), &quot;-1-&quot;, year(us_employment$Month)) ) retail = us_employment %&gt;% filter(Title == &quot;Retail Trade&quot;, year(date) &gt; 2002) To decompose this time series, we will follow this basic algorithm: First we will use a moving average of order \\(m=12\\) to get the trend, \\(T\\). Then, we will estimate the seasonal effects, \\(S\\),by fitting a linear regression model to the de-trendended series (\\(y-T\\)) in which the month is the explanatory variable. The remainder is the random component, \\(y-T-S\\). The trend captures the majority of the change that is observed in this time series, while the relative scale of the monthly seasonality and the random variation is small. 2.3 Statistical Models Thus far, we have explored time series data to better understand their properties. These exploration methods can also be used to generate forecasts for future values. However, they are not able to quantify the uncertainty inherent in those forecasts, nor do they model the dependency structure inherent in the time series data. We will begin with a very simple model that does both of these things. 2.3.1 Random Walk Let us consider a simple model to describe time series data, \\(y_t = y_{t-1}+e_t\\), where \\(e_t \\sim N(0, \\sigma^2)\\) and all elements of the error vector are mutually independent. Let’s derive some important properties of this model: What is the mean, \\(E(y_t)\\)? What is the variance, \\(Var(y_t)\\)? What is the covariance between successive observations, \\(\\text{cov}(y_t, y_{t-1})\\)? What is the correlation between successive observations, \\(\\text{cor}(y_t, y_{t-1})\\)? Which properties depend on time? 2.3.2 White noise Now let us define a new time series, \\(z_t = y_t - y_{t-1}\\). Define the same properties as 1-5 above. These two simple models are important in finance. If a time series follows a random walk, then its first difference is white noise. Let’s see if this is the case with GOOG. goog = getSymbols(&#39;GOOG&#39;, from=&#39;2020-12-22&#39;, to=&#39;2023-12-22&#39;,auto.assign = FALSE) googdf = data.frame(ymd(index(goog)), goog$GOOG.Close) names(googdf) = c(&quot;date&quot;, &quot;price&quot;) ggplot(googdf, aes(x = date, y = price)) + geom_line() + theme_minimal() + ggtitle(&quot;GOOG Closing Price&quot;) It seems plausible that this is a white noise series. How can we build further evidence of this. One way would be to examine the autocorrelation function. What are we looking for? This is helpful but visual evidence alone is fairly weak. We could alternatively use a hypothesis test (Box-Pierce test) in which: \\[\\begin{align} H_0 &amp;: \\rho_1 = \\rho_2 = \\ldots = \\rho_k = 0 \\\\ H_A &amp;: \\text{at least one autocorrelation is different from 0} \\end{align}\\] The test statistic (the Ljung-Box Q-Statistic) for this test: \\[\\begin{align} Q = n(n+2) \\sum_{i=1}^k \\frac{\\hat{\\rho}_i^2}{(n-k)} \\end{align}\\] follows a chi-squared distribution with \\(k\\) degrees of freedom under the null hypothesis. 2.4 Stationarity Stationarity is a convenient assumption that allows us to describe the statistical properties of a time series. A time series is said to be stationary if there is: No systematic change in the mean or the variance No systematic trend No periodic variations or seasonality 2.5 Lab 2 Change the es function we developed in Exponential Smoothing to return the SSE, rather than yt, the smoothed time series. Now, use the optim function to find the values of \\((\\alpha, l_0)\\) that minimize SSE. Plot the exponentially smoothed time series using the optimized values for \\((\\alpha, l_0)\\). Choose a different type of employee from the us_employment dataset and, first, plot the time series. Now, decompose the time series into trend, seasonal, and random components. Follow the algorithm in Decomposition. Plot these and comment on your observations. Simulate a Random Walk with 100 time points (\\(y_t\\), \\(T= 1,\\ldots,100\\)). Repeat this process 50 times. Choose your own \\(\\sigma^2\\) and use the same value for each of the 50 iterations. Plot all 50 time series on the same plot. On the title, report the \\(\\sigma^2\\) value you used. Second, make a histogram of each of the end points (i.e., the 100th observation of each of the 50 time series). How does this histogram correspond with the theoretical properties of \\(Y_{100}\\) (i.e., the mean, variance, and shape of the distribution)? Write a function that takes a time series vector as input and returns the Ljung-Box Q-Statistic for \\(k=2\\), along with the p-value for the hypothesis test in White Noise. Using the quantmod package, choose your favorite stock and see if the differenced version of its closing prices over the past year can be described as white noise. Include plots and the result of the Box test. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
